#include <Arduino.h>

#include "pico/stdlib.h"
#include "pico/multicore.h"

#include "hardware/pio.h"
#include "hardware/spi.h"
#include "hardware/irq.h"
#include "hardware/gpio.h"

#include <Adafruit_NeoPixel.h>

// SSD1306 OLED
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// PIO program header generated by pioasm from amt232_16b_falling_sample.pio
#include "amt232_16b_falling_sample.pio.h"

// ---------------------------
// User configuration
// ---------------------------
#define BYPASS_PIN       10

// AMT232 (input encoder) pins
#define ENC_CS_PIN        3
#define ENC_SCK_PIN       0
#define ENC_MISO_PIN      2

// ODrive SPI (RP2040 is SPI SLAVE) pins
#define ODRIVE_SPI        spi0
#define ODRIVE_SCK_PIN    4
#define ODRIVE_MISO_PIN   6
#define ODRIVE_CS_PIN     7

// ODrive MOSI is NC but the pin number used previously was 5.
// Keep it as an input pulldown to prevent floating noise.
#define ODRIVE_MOSI_NC_PIN 5

// I2C OLED pins (per your request)
#define OLED_SDA_PIN     14
#define OLED_SCL_PIN     15

#ifndef DEBUG
  #define DEBUG Serial
#endif

Adafruit_NeoPixel px(1, 16, NEO_GRB + NEO_KHZ800);

// Encoder timing
static constexpr uint32_t AMT232_MAX_SCLK_HZ = 2'000'000;
static constexpr uint32_t SAMPLE_PERIOD_US   = 200;      // 5 kHz nominal
static constexpr uint32_t ODRIVE_STARTUP_HIZ_MS = 1500;  // keep MISO hi-Z after boot

// Display timing
static constexpr uint32_t OLED_UPDATE_MS = 200;

// Virtual AEAT output resolution
static constexpr uint32_t VIRTUAL_BITS = 18;
static constexpr uint32_t CPR18 = (1u << VIRTUAL_BITS);  // 262,144
static constexpr float    DEG_PER_REV = 360.0f;

// Status LED (NeoPixel)
Adafruit_NeoPixel status_led(1, 16, NEO_GRB + NEO_KHZ800);

// OLED (128x64)
static constexpr int OLED_W = 128;
static constexpr int OLED_H = 64;
Adafruit_SSD1306 display(OLED_W, OLED_H, &Wire1, -1); // -1 = no reset pin

// ---------------------------
// Shared state between cores/ISRs
// ---------------------------
static volatile uint16_t g_amt_frame16 = 0xFFFF;   // latest raw AMT frame (for bypass)
static volatile uint32_t g_virtual18   = 0;        // latest virtual 18-bit angle
static volatile bool g_is_bypassed     = false;
static volatile bool g_spi_miso_enabled = false;
static volatile bool g_last_amt_valid  = false;    // last parity check result

// ---------------------------
// ODrive-style CUI parity (2-bit checkbits)
// ---------------------------
static inline uint8_t cui_parity(uint16_t v) {
    v ^= v >> 8;
    v ^= v >> 4;
    v ^= v >> 2;
    return (uint8_t)(~v & 3);
}

static inline bool amt232_even_parity_ok(uint16_t frame16) {
    uint16_t pos14 = frame16 & 0x3FFF;
    uint8_t chk2   = (uint8_t)((frame16 >> 14) & 0x03);
    uint8_t exp2   = cui_parity(pos14);
    return chk2 == exp2;
}

// ---------------------------
// Virtual 18-bit filter: alpha-beta (steady-state Kalman for const-vel)
// ---------------------------
class AlphaBeta18 {
public:
    static constexpr int Q = 14;

    // Tuning (conservative defaults for telescope tracking)
    static constexpr int G_SHIFT = 10;   // g = 24/1024 ≈ 0.0234
    static constexpr int H_SHIFT = 18;   // h = 120/262144 ≈ 0.000458
    static constexpr int G_NUM   = 24;
    static constexpr int H_NUM   = 120;

    bool initialized = false;
    int32_t x_q = 0;   // position Q
    int32_t v_q = 0;   // velocity Q per sample

    int32_t last_raw14 = 0;
    int32_t turns14 = 0;

    static inline int32_t raw14_to_18(int32_t raw14) { return (raw14 << 4); }

    int32_t unwrap14(int32_t raw14) {
        if (!initialized) {
            last_raw14 = raw14;
            turns14 = 0;
            return raw14;
        }
        int32_t d = raw14 - last_raw14;
        if (d > 8192)  turns14 -= 16384;
        if (d < -8192) turns14 += 16384;
        last_raw14 = raw14;
        return turns14 + raw14;
    }

    static inline uint32_t wrap18(int32_t x18) {
        int32_t m = (int32_t)CPR18;
        int32_t r = x18 % m;
        if (r < 0) r += m;
        return (uint32_t)r;
    }

    uint32_t update(uint16_t raw14) {
        int32_t raw14_i = (int32_t)(raw14 & 0x3FFF);

        int32_t unwrapped14 = unwrap14(raw14_i);
        int32_t z18 = raw14_to_18(unwrapped14);

        if (!initialized) {
            initialized = true;
            x_q = (z18 << Q);
            v_q = 0;
            return wrap18(z18);
        }

        // Predict
        x_q += v_q;

        // Residual
        int32_t z_q = (z18 << Q);
        int32_t r_q = z_q - x_q;

        // Update
        x_q += (int32_t)((int64_t)r_q * G_NUM >> G_SHIFT);
        v_q += (int32_t)((int64_t)r_q * H_NUM >> H_SHIFT);

        return wrap18(x_q >> Q);
    }
};

// ---------------------------
// SPI slave helpers (ODrive interface)
// ---------------------------
static inline void spi_flush_rx(spi_inst_t* spi) {
    spi_hw_t* hw = spi_get_hw(spi);
    while (hw->sr & SPI_SSPSR_RNE_BITS) {
        (void)hw->dr;
    }
}

static inline void spi_clear_fifos(spi_inst_t* spi) {
    spi_hw_t* hw = spi_get_hw(spi);
    hw->cr1 &= ~SPI_SSPCR1_SSE_BITS;
    __asm volatile("nop \n nop \n nop");
    hw->cr1 |=  SPI_SSPCR1_SSE_BITS;
}

// BYPASS: send [0x00][frame_hi][frame_lo]
static inline void spi_load_tx_bypass24(spi_inst_t* spi, uint16_t frame16) {
    spi_hw_t* hw = spi_get_hw(spi);
    spi_flush_rx(spi);

    uint8_t b0 = 0x00;
    uint8_t b1 = (uint8_t)((frame16 >> 8) & 0xFF);
    uint8_t b2 = (uint8_t)(frame16 & 0xFF);

    while (!(hw->sr & SPI_SSPSR_TNF_BITS)) {}
    hw->dr = b0;
    while (!(hw->sr & SPI_SSPSR_TNF_BITS)) {}
    hw->dr = b1;
    while (!(hw->sr & SPI_SSPSR_TNF_BITS)) {}
    hw->dr = b2;
}

// VIRTUAL AEAT18: pack 18-bit angle into 24 clocks as:
// [ (angle>>16)&0x03 ][ (angle>>8)&0xFF ][ angle&0xFF ]
static inline void spi_load_tx_virtual_aeat24(spi_inst_t* spi, uint32_t angle18) {
    spi_hw_t* hw = spi_get_hw(spi);
    spi_flush_rx(spi);

    angle18 &= (CPR18 - 1);

    uint8_t b0 = (uint8_t)((angle18 >> 16) & 0x03);
    uint8_t b1 = (uint8_t)((angle18 >> 8) & 0xFF);
    uint8_t b2 = (uint8_t)(angle18 & 0xFF);

    while (!(hw->sr & SPI_SSPSR_TNF_BITS)) {}
    hw->dr = b0;
    while (!(hw->sr & SPI_SSPSR_TNF_BITS)) {}
    hw->dr = b1;
    while (!(hw->sr & SPI_SSPSR_TNF_BITS)) {}
    hw->dr = b2;
}

// GPIO IRQ on ODrive CS: preload TX at transaction start
static void __isr gpio_cs_irq(uint gpio, uint32_t events) {
    if (gpio != ODRIVE_CS_PIN) return;
    if (!g_spi_miso_enabled) return;

    if (events & GPIO_IRQ_EDGE_FALL) {
        spi_clear_fifos(ODRIVE_SPI);

        if (g_is_bypassed) {
            spi_load_tx_bypass24(ODRIVE_SPI, g_amt_frame16);
        } else {
            spi_load_tx_virtual_aeat24(ODRIVE_SPI, g_virtual18);
        }
    }

    if (events & GPIO_IRQ_EDGE_RISE) {
        spi_flush_rx(ODRIVE_SPI);
    }
}

// ---------------------------
// Display update (core0)
// ---------------------------
static void oled_update() {
    // Snapshot shared variables (avoid tearing)
    bool bypass = g_is_bypassed;
    bool parity_ok = g_last_amt_valid;
    uint16_t frame16 = g_amt_frame16;
    uint32_t virt18 = g_virtual18 & (CPR18 - 1);

    uint16_t pos14 = (uint16_t)(frame16 & 0x3FFF);

    float deg;
    if (bypass) {
        deg = (360.0f * (float)pos14) / 16384.0f;
    } else {
        deg = (360.0f * (float)virt18) / (float)CPR18;
    }

    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);

    // Line 1
    display.setCursor(0, 0);
    display.print("Mode: ");
    display.print(bypass ? "BYPASS" : "VIRT18");

    // Line 2: both counts
    // Fits on 128px wide screen with size=1 font:
    // "14b:16383 18b:262143" is 19 chars + spaces -> OK.
    display.setCursor(0, 16);
    display.print("14b:");
    display.print(pos14);
    display.print(" 18b:");
    display.print(virt18);

    // Line 3
    display.setCursor(0, 32);
    display.print("Parity: ");
    display.print(parity_ok ? "OK" : "FAIL");

    // Line 4
    display.setCursor(0, 48);
    display.print("Deg: ");
    display.print(deg, 2);

    display.display();
}

// ---------------------------
// Core1: read AMT232 via PIO + update virtual angle
// ---------------------------
static void core1_entry() {
    PIO pio = pio0;
    const uint sm = 0;

    uint offset = pio_add_program(pio, &amt232_16b_falling_sample_program);

    pio_gpio_init(pio, ENC_SCK_PIN);
    pio_gpio_init(pio, ENC_MISO_PIN);

    gpio_init(ENC_CS_PIN);
    gpio_set_dir(ENC_CS_PIN, GPIO_OUT);
    gpio_put(ENC_CS_PIN, 1);

    static uint32_t last = 0;
    uint32_t now = to_ms_since_boot(get_absolute_time());
    if (now - last > 1000) {
    last = now;
        status_led.setPixelColor(0, status_led.Color(0, 128, 255));
    }
    
    pio_sm_config c = amt232_16b_falling_sample_program_get_default_config(offset);
    sm_config_set_sideset_pins(&c, ENC_SCK_PIN);
    sm_config_set_in_pins(&c, ENC_MISO_PIN);

    // Program includes explicit PUSH, so keep autopush off.
    sm_config_set_in_shift(&c, /*shift_right=*/false, /*autopush=*/false, /*push_thresh=*/32);

    const float clkdiv = 125'000'000.0f / (2.0f * (float)AMT232_MAX_SCLK_HZ);
    sm_config_set_clkdiv(&c, clkdiv);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_consecutive_pindirs(pio, sm, ENC_SCK_PIN, 1, true);
    pio_sm_set_consecutive_pindirs(pio, sm, ENC_MISO_PIN, 1, false);
    pio_sm_set_enabled(pio, sm, true);

    AlphaBeta18 filter;

    while (true) {
        // Clear stale RX FIFO
        while (!pio_sm_is_rx_fifo_empty(pio, sm)) {
            (void)pio_sm_get(pio, sm);
        }

        // Read full 16-bit AMT232 frame
        gpio_put(ENC_CS_PIN, 0);
        sleep_us(1);

        pio_sm_put_blocking(pio, sm, 0);
        uint32_t raw32 = pio_sm_get_blocking(pio, sm);

        gpio_put(ENC_CS_PIN, 1);

        uint16_t frame16 = (uint16_t)(raw32 & 0xFFFFu);
        g_amt_frame16 = frame16;

        bool ok = amt232_even_parity_ok(frame16);
        g_last_amt_valid = ok;

        // Non-bypass: update only on good parity; else hold last good.
        if (!g_is_bypassed && ok) {
            uint16_t raw14 = (uint16_t)(frame16 & 0x3FFF);
            g_virtual18 = filter.update(raw14);
        }

        sleep_us(SAMPLE_PERIOD_US);
    }
}


void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("USB CDC alive");

  pinMode(BYPASS_PIN, INPUT_PULLUP);
  delay(10);
  //g_is_bypassed = (digitalRead(BYPASS_PIN) == LOW);

  status_led.begin();
  status_led.setPixelColor(0, g_is_bypassed ? status_led.Color(0, 0, 255)
                                            : status_led.Color(0, 255, 0));
  status_led.show();

  delay(1000);
  status_led.setPixelColor(0, status_led.Color(0, 128, 255));

  // I2C OLED on GPIO14/15
  Wire1.setSDA(OLED_SDA_PIN);
  Wire1.setSCL(OLED_SCL_PIN);
  Wire1.begin();

  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
      // If display isn't found, just continue without it.
      // (No Serial spam in case you run headless)
  } else {
      display.clearDisplay();
      display.setTextSize(1);
      display.setTextColor(SSD1306_WHITE);
      display.setCursor(0, 0);
      display.print("Encoder Bridge");
      display.setCursor(0, 16);
      display.print("Booting...");
      display.display();
  }

  //multicore_launch_core1(core1_entry);
    DEBUG.printf("launch core1");

    delay(1000);

    // SPI0 slave init
    //spi_init(ODRIVE_SPI, 1'000'000);
    //spi_set_slave(ODRIVE_SPI, true);
    //spi_set_format(ODRIVE_SPI, 8, SPI_CPOL_0, SPI_CPHA_1, SPI_MSB_FIRST);

    gpio_set_function(ODRIVE_SCK_PIN, GPIO_FUNC_SPI);
    gpio_set_function(ODRIVE_CS_PIN,  GPIO_FUNC_SPI);

    // ODrive MOSI is NC: define pin so it doesn't float
    gpio_init(ODRIVE_MOSI_NC_PIN);
    gpio_set_dir(ODRIVE_MOSI_NC_PIN, GPIO_IN);
    gpio_pull_down(ODRIVE_MOSI_NC_PIN);

    // Keep MISO hi-Z initially to avoid contention
    gpio_init(ODRIVE_MISO_PIN);
    gpio_set_dir(ODRIVE_MISO_PIN, GPIO_IN);
    gpio_disable_pulls(ODRIVE_MISO_PIN);
    // gpio_set_irq_enabled_with_callback(
    //     ODRIVE_CS_PIN,
    //     GPIO_IRQ_EDGE_FALL | GPIO_IRQ_EDGE_RISE,
    //     true,
    //     &gpio_cs_irq
    // );

    DEBUG.printf("GPIOs have been Setup");

    // Delay before we start driving MISO
    //sleep_ms(ODRIVE_STARTUP_HIZ_MS);
    gpio_set_function(ODRIVE_MISO_PIN, GPIO_FUNC_SPI);
    //g_spi_miso_enabled = true;

    //g_amt_frame16 = 0xFFFF;
    //g_virtual18   = 0;
    //g_last_amt_valid = false;
  delay(1000);

  px.begin();
  px.setBrightness(20);
  px.clear();
  px.show();

  Serial.println("USB CDC alive");
}

void loop() {
    static uint32_t last_ms = 0;
    uint32_t now = millis();
    //if ((now - last_ms) >= OLED_UPDATE_MS) {
    //    last_ms = now;
    //    oled_update();
    //}
    DEBUG.printf("loop");
    delay(1000);
    //tight_loop_contents();
}
