// Encoder Interpolator Bridge
// Converts AMS232B encoder 14 bits to a virtual AEAT9922 18 bits
// Intended to be used with the DDScopeX Telescope project
// Requires the modified ODrive3.6(AEAT9922) code found elsewhere in my repositories
// Author: Richard Benear 2/17/2026

#include <Arduino.h>

#include "pico/stdlib.h"
#include "pico/multicore.h"

#include "hardware/pio.h"
#include "hardware/spi.h"
#include "hardware/gpio.h"

#include <Adafruit_NeoPixel.h>

// SSD1306 OLED
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// PIO program header generated by pioasm from amt232_16b_falling_sample.pio
#include "amt232_16b_falling_sample.pio.h"

// ---------------------------
// Configuration
// ---------------------------
#define BYPASS_PIN       10

// AMT232 encoder pins
#define ENC_CS_PIN        3
#define ENC_SCK_PIN       0
#define ENC_MISO_PIN      2

// ODrive SPI (RP2040 is SPI SLAVE) pins
#define ODRIVE_SPI           spi0
#define ODRIVE_SCK_PIN       6
#define ODRIVE_MISO_PIN      7
#define ODRIVE_CS_PIN        5

// ODrive MOSI is NC
// Keep it as an input pulldown to prevent floating noise.
#define ODRIVE_MOSI_NC_PIN 4

// I2C OLED pins
#define OLED_SDA_PIN     14
#define OLED_SCL_PIN     15

// Encoder timing
static constexpr uint32_t AMT232_MAX_SCLK_HZ = 2'000'000;
static constexpr uint32_t SAMPLE_PERIOD_US   = 100;   

// Parity/checkbits stats (updated on core1)
static volatile uint32_t g_amt_total = 0;
static volatile uint32_t g_amt_bad   = 0;

// windowed stats over last N samples (more responsive) 
static constexpr uint32_t PARITY_WINDOW_N = 1000; 
static volatile uint32_t g_amt_total_win = 0; 
static volatile uint32_t g_amt_bad_win = 0;

// Display timing
static constexpr uint32_t OLED_UPDATE_MS = 500;

// Virtual AEAT output resolution
static constexpr uint32_t VIRTUAL_BITS = 18;
static constexpr uint32_t CPR18 = (1u << VIRTUAL_BITS);  // 262,144

// Status LED (NeoPixel)
Adafruit_NeoPixel status_led(1, 16, NEO_GRB + NEO_KHZ800);

// OLED (128x64)
static constexpr int OLED_W = 128;
static constexpr int OLED_H = 64;
Adafruit_SSD1306 display(OLED_W, OLED_H, &Wire1, -1); // -1 = no reset pin
static bool g_oled_ok = false;

// ---------------------------
// Shared state between cores/ISRs
// ---------------------------
static volatile uint32_t g_virtual18   = 0;        // latest virtual 18-bit angle
static volatile bool g_is_bypassed     = false;
static volatile uint16_t g_amt_frame16 = 0x8000;   // latest raw AMT frame
static volatile bool g_last_amt_valid  = false;    // last parity check result

//===================================================
// ---------------------------
// Published frame (ping-pong) from core1 -> core0 ISR
// ---------------------------
struct PublishedFrame {
    uint8_t len;      // 2 (bypass16) or 3 (virt18/24 clocks)
    uint8_t b[3];
};

// Two buffers + published index.
// Core1 writes the non-published buffer then flips index.
// Core0 ISR only reads the currently published buffer.
static volatile PublishedFrame g_pub[2];
static volatile uint8_t g_pub_idx = 0;

static inline void dmb() {
    __asm volatile("dmb" ::: "memory");
}

// Core1: publish a complete frame atomically via index flip.
static inline void publish_frame(uint8_t len, uint8_t b0, uint8_t b1, uint8_t b2) {
    uint8_t w = (uint8_t)(g_pub_idx ^ 1u);
    g_pub[w].len = len;
    g_pub[w].b[0] = b0;
    g_pub[w].b[1] = b1;
    g_pub[w].b[2] = b2;
    dmb();              // ensure frame content committed before publishing
    g_pub_idx = w;
    dmb();
}

static inline uint8_t odrive_cui_checkbits(uint16_t pos14) {
    pos14 &= 0x3FFF;
    uint16_t v = pos14;
    v ^= v >> 8;
    v ^= v >> 4;
    v ^= v >> 2;
    return (uint8_t)(~v & 0x3);   // 2-bit check value
}

uint8_t aeat9922_parity(uint32_t data) {
    uint32_t p = data;
    // No need for p ^= p >> 16 if we are only dealing with 19 bits, 
    // but keeping it makes the function universal.
    p ^= p >> 16;
    p ^= p >> 8;
    p ^= p >> 4;
    p ^= p >> 2;
    p ^= p >> 1;
    return p & 1; 
}

static inline bool odrive_cui_frame_ok(uint16_t frame16) {
    uint16_t pos14 = frame16 & 0x3FFF;
    uint8_t chk2 = (frame16 >> 14) & 0x3;
    return chk2 == odrive_cui_checkbits(pos14);
}

// ---------------------------
// Virtual 18-bit filter: alpha-beta (steady-state Kalman for const-vel)
// ---------------------------
class AlphaBeta18 {
public:
    static constexpr int Q = 14;

    // Tuning (conservative defaults for telescope tracking)
    static constexpr int G_SHIFT = 10;   // g = 24/1024 ≈ 0.0234
    static constexpr int H_SHIFT = 18;   // h = 120/262144 ≈ 0.000458
    static constexpr int G_NUM   = 24;
    static constexpr int H_NUM   = 120;

    bool initialized = false;
    int32_t x_q = 0;   // position Q
    int32_t v_q = 0;   // velocity Q per sample

    int32_t last_raw14 = 0;
    int32_t turns14 = 0;

    static inline int32_t raw14_to_18(int32_t raw14) { return (raw14 << 4); }

    int32_t unwrap14(int32_t raw14) {
        if (!initialized) {
            last_raw14 = raw14;
            turns14 = 0;
            return raw14;
        }
        int32_t d = raw14 - last_raw14;
        if (d > 8192)  turns14 -= 16384;
        if (d < -8192) turns14 += 16384;
        last_raw14 = raw14;
        return turns14 + raw14;
    }

    static inline uint32_t wrap18(int32_t x18) {
        int32_t m = (int32_t)CPR18;
        int32_t r = x18 % m;
        if (r < 0) r += m;
        return (uint32_t)r;
    }

    uint32_t update(uint16_t raw14) {
        int32_t raw14_i = (int32_t)(raw14 & 0x3FFF);

        int32_t unwrapped14 = unwrap14(raw14_i);
        int32_t z18 = raw14_to_18(unwrapped14);

        if (!initialized) {
            initialized = true;
            x_q = (z18 << Q);
            v_q = 0;
            return wrap18(z18);
        }

        // Predict
        x_q += v_q;

        // Residual
        int32_t z_q = (z18 << Q);
        int32_t r_q = z_q - x_q;

        // Update
        x_q += (int32_t)((int64_t)r_q * G_NUM >> G_SHIFT);
        v_q += (int32_t)((int64_t)r_q * H_NUM >> H_SHIFT);

        return wrap18(x_q >> Q);
    }
};

static inline void build_aeat9922_frame(uint32_t angle18, bool error_flag, uint8_t out[3]) {
    // 1. Clean the 18-bit angle and place the error flag at bit 18
    uint32_t frame24 = (angle18 & 0x3FFFF); 
    if (error_flag) {
        frame24 |= (1UL << 18);
    }

    // 2. Compute parity over bits 18..0 (19 bits total)
    uint8_t par = aeat9922_parity(frame24); 

    // 3. Set bit 19 as the parity bit
    frame24 |= ((uint32_t)par << 19);

    // 4. Map to MSB-first bytes
    out[0] = (uint8_t)((frame24 >> 16) & 0xFF);
    out[1] = (uint8_t)((frame24 >> 8)  & 0xFF);
    out[2] = (uint8_t)(frame24 & 0xFF);
}

static void __isr cs_irq(uint gpio, uint32_t events) {
    if (gpio != ODRIVE_CS_PIN) return;
    spi_hw_t* hw = spi_get_hw(ODRIVE_SPI);

    if (events & GPIO_IRQ_EDGE_RISE) {

        // Drain RX FIFO (junk from master)
        while (hw->sr & SPI_SSPSR_RNE_BITS) {
            (void)hw->dr;
        }

        // Wait until SPI is not busy (prevents partial-frame reset issues)
        while (hw->sr & SPI_SSPSR_BSY_BITS) {
            __asm volatile("nop");
        }

        // Hard reset SPI state (clears FIFOs + shifter state)
        hw->cr1 &= ~SPI_SSPCR1_SSE_BITS;
        __asm volatile("nop \n nop \n nop");
        hw->cr1 |=  SPI_SSPCR1_SSE_BITS;

        // Snapshot the published frame (single read of index)
        uint8_t r = g_pub_idx;
        dmb(); // acquire barrier: ensure subsequent reads see the frame published before g_pub_idx flipped
        PublishedFrame f;
        f.len = g_pub[r].len;
        f.b[0] = g_pub[r].b[0];
        f.b[1] = g_pub[r].b[1];
        f.b[2] = g_pub[r].b[2];
        
        // 6) Load the entire frame (2 or 3 bytes) into TX FIFO
        // Note: In bypass mode we configured SPI for 16-bit frames, but
        // writing bytes still works because DR is 16-bit wide; the PL022
        // will use the bottom bits according to DSS. The safest is:
        //   - If len==2 and DSS==16: write a 16-bit word once.
        //   - Else: write bytes.
        if (f.len == 2 && g_is_bypassed) {
            uint16_t w16 = (uint16_t)((uint16_t)f.b[0] << 8) | (uint16_t)f.b[1];
            hw->dr = w16;
        } else {
            hw->dr = f.b[0];
            hw->dr = f.b[1];
            hw->dr = f.b[2];
        }
        return;
    }
}

// Update globals and keep the SPI primed if the IRQ isn't active.
static void core1_entry() {
    PIO pio = pio0;
    const uint sm = 0;

    uint offset = pio_add_program(pio, &amt232_16b_falling_sample_program);

    pio_gpio_init(pio, ENC_SCK_PIN);
    pio_gpio_init(pio, ENC_MISO_PIN);

    gpio_init(ENC_CS_PIN);
    gpio_set_dir(ENC_CS_PIN, GPIO_OUT);
    gpio_put(ENC_CS_PIN, 1);
    
    pio_sm_config c = amt232_16b_falling_sample_program_get_default_config(offset);
    sm_config_set_sideset_pins(&c, ENC_SCK_PIN);
    sm_config_set_in_pins(&c, ENC_MISO_PIN);

    // Program includes explicit PUSH, so keep autopush off.
    sm_config_set_in_shift(&c, /*shift_right=*/false, /*autopush=*/false, /*push_thresh=*/32);

    const float clkdiv = 125'000'000.0f / (2.0f * (float)AMT232_MAX_SCLK_HZ);
    sm_config_set_clkdiv(&c, clkdiv);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_consecutive_pindirs(pio, sm, ENC_SCK_PIN, 1, true);
    pio_sm_set_consecutive_pindirs(pio, sm, ENC_MISO_PIN, 1, false);
    pio_sm_set_enabled(pio, sm, true);

    AlphaBeta18 filter;

    uint64_t next = time_us_64();
    while (true) {
        next += SAMPLE_PERIOD_US;

        // Clear stale RX FIFO
        while (!pio_sm_is_rx_fifo_empty(pio, sm)) {
            (void)pio_sm_get(pio, sm);
        }

        // Get Encoder data
        gpio_put(ENC_CS_PIN, 0);
        sleep_us(1);
        pio_sm_put_blocking(pio, sm, 0); // trigger PIO asm
        uint32_t raw32 = pio_sm_get_blocking(pio, sm);
        gpio_put(ENC_CS_PIN, 1);

        uint16_t frame16 = (uint16_t)(raw32 & 0xFFFFu);
        g_amt_frame16 = frame16; // keep for display/debug

        bool ok = odrive_cui_frame_ok(frame16);
        g_last_amt_valid = ok;

        g_amt_total++;
        if (!ok) g_amt_bad++;

        g_amt_total_win++;
        if (!ok) g_amt_bad_win++;

        // keep window bounded
        if (g_amt_total_win >= PARITY_WINDOW_N) {
            // subtract an approximation or reset window:
            g_amt_total_win = 0;
            g_amt_bad_win   = 0;
        }

        if (ok) {
            uint16_t raw14 = (uint16_t)(frame16 & 0x3FFF);
            g_virtual18 = filter.update(raw14);
        }

        // Publish a *complete* response frame for the next ODrive transaction.
        // Note: even if parity fails, we still publish something deterministic.
        if (g_is_bypassed) {
            publish_frame(2,
                        (uint8_t)(frame16 >> 8),
                        (uint8_t)(frame16 & 0xFF),
                        0);
        } else {
            uint8_t b[3];
            build_aeat9922_frame(g_virtual18, !ok, b);
            publish_frame(3, b[0], b[1], b[2]);

        }

        while ((int64_t)(time_us_64() - next) < 0) {
            tight_loop_contents();
        }
    }
}

// ---------------------------
// Display update (core0)
// ---------------------------
static void oled_update() {
    // Snapshot shared variables
    bool parity_ok = g_last_amt_valid;
    uint16_t frame16 = g_amt_frame16;
    uint32_t virt18 = g_virtual18 & (CPR18 - 1);
    uint16_t pos14 = (uint16_t)(frame16 & 0x3FFF);

    uint32_t total = g_amt_total;
    uint32_t bad   = g_amt_bad;

    uint32_t totalw = g_amt_total_win; 
    uint32_t badw = g_amt_bad_win;

    float bad_pct = (total > 0) ? (100.0f * (float)bad / (float)total) : 0.0f; 
    float badw_pct = (totalw > 0) ? (100.0f * (float)badw / (float)totalw) : 0.0f;

    float deg;
    if (g_is_bypassed) {
        deg = (360.0f * (float)pos14) / 16384.0f;
    } else {
        deg = (360.0f * (float)virt18) / (float)CPR18;
    }

    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);

    // Line 1
    display.setCursor(0, 0);
    display.print("Ver:0.5-Mode: ");
    display.print(g_is_bypassed ? "BYPASS" : "VIRT18");

    // Line 2: both counts
    // Fits on 128px wide screen with size=1 font:
    // "14b:16383 18b:262143" is 19 chars + spaces -> OK.
    display.setCursor(0, 17);
    display.print("14b:");
    display.print(pos14);
    display.print(" 18b:");
    display.print(virt18);

    // Line 3
    display.setCursor(0, 28);
    display.print("Parity: ");
    display.print(parity_ok ? "OK" : "FAIL");

    // Line 4
    display.setCursor(0, 41);
    display.print("Deg: ");
    display.print(deg, 2);

    display.setCursor(0, 56);
    display.print("Bad:");
    display.print(bad);
    display.print(" ");
    display.print(bad_pct, 2);
    display.print("% ");

    display.print("W:"); 
    display.print(badw); 
    display.print(" "); 
    display.print(badw_pct, 2); 
    display.print("%");

    display.display();
}

// ---------------------------
// Setup / loop (core0)
// ---------------------------
void setup() {
    pinMode(BYPASS_PIN, INPUT_PULLUP);
    delay(1);
    g_is_bypassed = (digitalRead(BYPASS_PIN) == LOW);
    gpio_set_function(ODRIVE_SCK_PIN, GPIO_FUNC_SPI);
    gpio_set_function(ODRIVE_CS_PIN,  GPIO_FUNC_SPI);
    gpio_set_function(ODRIVE_MISO_PIN, GPIO_FUNC_SPI);

    // ODrive MOSI is NC: define pin so it doesn't float
    gpio_init(ODRIVE_MOSI_NC_PIN);
    gpio_set_dir(ODRIVE_MOSI_NC_PIN, GPIO_IN);
    gpio_pull_down(ODRIVE_MOSI_NC_PIN);

    // SPI0 slave init
    spi_init(ODRIVE_SPI, 1'000'000);
    spi_set_slave(ODRIVE_SPI, true);
    if (g_is_bypassed){
        spi_set_format(ODRIVE_SPI, 16, SPI_CPOL_0, SPI_CPHA_1, SPI_MSB_FIRST);
    } else {
        spi_set_format(ODRIVE_SPI, 8, SPI_CPOL_0, SPI_CPHA_1, SPI_MSB_FIRST);
    }
    
    // Start the PIO SPI to encoder
    multicore_launch_core1(core1_entry);

    // I2C OLED on GPIO14/15
    Wire1.setSDA(OLED_SDA_PIN);
    Wire1.setSCL(OLED_SCL_PIN);
    Wire1.begin();

    g_oled_ok = display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
    if (!g_oled_ok) {
        // If display isn't found, just continue without it.
        // (No Serial spam in case you run headless)
    } else {
        display.clearDisplay();
        display.setTextSize(1);
        display.setTextColor(SSD1306_WHITE);
        display.setCursor(0, 0);
        display.print("Encoder Bridge");
        display.setCursor(0, 16);
        display.print("Booting...");
        display.display();
    }

    // Start the IRQ
    g_amt_frame16 = 0x8000;
    g_virtual18   = 0;
    g_last_amt_valid = false;

    // Seed published frame so the first transaction has valid data
    if (g_is_bypassed) {
        publish_frame(2, (uint8_t)(g_amt_frame16 >> 8), (uint8_t)(g_amt_frame16 & 0xFF), 0);
    } else {
        uint8_t b[3];
        build_aeat9922_frame(g_virtual18, /*error_flag=*/false, b);
        publish_frame(3, b[0], b[1], b[2]);
    }

    gpio_set_irq_enabled_with_callback(
        ODRIVE_CS_PIN,
        GPIO_IRQ_EDGE_RISE,
        true,
        &cs_irq
    );

    status_led.begin();
    status_led.setPixelColor(0, g_is_bypassed ? status_led.Color(0, 0, 255)
                                              : status_led.Color(0, 255, 0));
    status_led.show();
}

void loop() {

    static uint32_t last_ms = 0;
    uint32_t now = millis();
    if ((now - last_ms) >= OLED_UPDATE_MS && g_oled_ok) {
        last_ms = now;
        oled_update();
    }

    tight_loop_contents();
}
